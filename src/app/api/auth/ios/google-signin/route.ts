import { NextRequest, NextResponse } from 'next/server';
import { OAuth2Client } from 'google-auth-library';
import { encode } from 'next-auth/jwt';
import { markUserAsAuthenticated, isUserPaid, markUserAsPaid } from '@/lib/auth'; // Assuming these are exported from your auth.ts

const GOOGLE_IOS_CLIENT_ID = process.env.GOOGLE_IOS_CLIENT_ID;
const GOOGLE_IOS_CLIENT_SECRET = process.env.GOOGLE_IOS_CLIENT_SECRET; // Needed for server-side code exchange
const NEXTAUTH_SECRET = process.env.NEXTAUTH_SECRET;

if (!GOOGLE_IOS_CLIENT_ID) {
  console.warn('GOOGLE_IOS_CLIENT_ID is not set. iOS Google Sign-In will not work.');
}
if (!GOOGLE_IOS_CLIENT_SECRET) {
  console.warn('GOOGLE_IOS_CLIENT_SECRET is not set. iOS Google Sign-In code exchange will not work.');
}
if (!NEXTAUTH_SECRET) {
  throw new Error('NEXTAUTH_SECRET is not set. Cannot encode JWT.');
}

const oauth2Client = new OAuth2Client(
  GOOGLE_IOS_CLIENT_ID,
  GOOGLE_IOS_CLIENT_SECRET
  // No redirect_uri is typically needed here for code exchange from mobile if done correctly
);

export async function POST(request: NextRequest) {
  if (!GOOGLE_IOS_CLIENT_ID || !GOOGLE_IOS_CLIENT_SECRET || !NEXTAUTH_SECRET) {
    return NextResponse.json(
      { error: 'Server configuration error: Missing Google iOS client credentials or JWT secret.' },
      { status: 500 }
    );
  }

  try {
    const { serverAuthCode } = await request.json();

    if (!serverAuthCode || typeof serverAuthCode !== 'string') {
      return NextResponse.json(
        { error: 'Invalid request: serverAuthCode is required.' },
        { status: 400 }
      );
    }

    // Exchange the authorization code for tokens
    const { tokens } = await oauth2Client.getToken(serverAuthCode);
    
    if (!tokens.id_token) {
      return NextResponse.json(
        { error: 'Failed to retrieve ID token from Google.' },
        { status: 500 }
      );
    }

    // Verify the ID token and get user info
    // The `verifyIdToken` method can also be used if you directly receive an ID token
    const ticket = await oauth2Client.verifyIdToken({
      idToken: tokens.id_token,
      audience: GOOGLE_IOS_CLIENT_ID, 
    });

    const payload = ticket.getPayload();

    if (!payload || !payload.email || !payload.sub) {
      return NextResponse.json(
        { error: 'Invalid ID token payload.' },
        { status: 500 }
      );
    }

    const { email, sub: googleUserId, name, picture } = payload;

    // --- User Management (using demo functions from auth.ts) ---
    // In a real application, you would find or create a user in your database here.
    // For this demo, we'll use the helper functions.
    markUserAsAuthenticated(email); 

    // Example: If users pre-pay or have invite codes, you might check that status.
    // For simplicity, let's assume if they authenticate this way, they are also marked as paid (for demo purposes)
    if (!isUserPaid(email)) {
      markUserAsPaid(email); // Mark as paid for demo purposes
    }
    // --- End User Management ---

    // Create your application's JWT
    const appJwtPayload = {
      sub: googleUserId, // Use Google's user ID as the subject
      userId: googleUserId, // Or your internal user ID if you map it
      email: email,
      name: name,
      picture: picture,
      isIosApp: true, // Flag to identify this session originated from iOS
      // Add any other claims your application needs
      // Match the structure of JWTs generated by next-auth if possible for consistency
      // next-auth typically includes iat, exp, jti
    };

    const appToken = await encode({
      token: appJwtPayload,
      secret: NEXTAUTH_SECRET,
      maxAge: 30 * 24 * 60 * 60, // 30 days, same as next-auth session
    });

    return NextResponse.json({
      success: true,
      message: 'User authenticated successfully via iOS Google Sign-In.',
      sessionToken: appToken,
      user: {
        id: googleUserId,
        email: email,
        name: name,
      },
    });

  } catch (error: any) {
    console.error('iOS Google Sign-In Error:', error);
    let errorMessage = 'Authentication failed.';
    if (error.response?.data?.error_description) {
      errorMessage = error.response.data.error_description;
    } else if (error.message) {
      errorMessage = error.message;
    }
    return NextResponse.json(
      { error: errorMessage }, 
      { status: 500 }
    );
  }
} 