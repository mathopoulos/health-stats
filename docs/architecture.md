# Project Architecture

This document captures the high-level structure, naming rules, and conventions for the *Health-Stats* code-base.

---

## 1. Directory Layout

```
.
├─ infra/                # Deployment + operational tooling (never imported by the app)
│  ├─ aws/               # CloudFormation / Lambda helpers
│  └─ scripts/           # One-off migration & data scripts
├─ public/               # Static assets served by Next.js
├─ src/
│  ├─ app/               # Next.js App-Router tree (pages, route handlers, RSC)
│  │  └─ api/            # HTTP route handlers only (no business logic)
│  ├─ components/        # Shared UI (cross-feature). Keep feature-owned UI in features/*
│  │  └─ ui/             # Low-level primitives (Card, Skeleton, Dialog…). Barrel in index.ts
│  ├─ features/          # Feature folders own their UI, hooks, and utils
│  ├─ providers/         # App-level providers (e.g., SessionProvider, ThemeProvider)
│  ├─ server/            # Server-only modules (no React) – business logic lives here
│  │  ├─ aws/            # S3, Lambda clients & helpers
│  │  ├─ payments/       # Stripe client & helpers
│  │  ├─ jobs/           # Background job persistence & status helpers
│  │  └─ processing/     # Long-running/processing flows (canonical imports)
│  ├─ db/                # Database client & schema constants (e.g., Mongo client)
│  ├─ lib/               # Shared utilities (pure helpers, auth config, parsing)
│  │  ├─ auth.ts         # NextAuth configuration
│  │  ├─ auth-proxy.ts   # OAuth proxy utilities for stable redirect URIs
│  │  ├─ auth-secrets.ts # Shared secret management for OAuth
│  │  └─ utils.ts        # UI-agnostic helpers (e.g., cn)
│  ├─ types/             # Shared domain and API types (no ambient declarations)
│  ├─ constants/         # App-wide constants and configuration (sleep targets, etc.)
│  └─ test-utils/        # Testing utilities and custom render functions
├─ types/                # Ambient global .d.ts for third‑party modules (picked up via typeRoots)
└─ docs/                 # Internal documentation (you are here)
```

### Rules

1. **No business logic inside `src/app/api`.** Route handlers are thin. Real work lives in `src/server/*` (primary) or `src/features/*` (UI-adjacent helpers). `src/lib` is for shared, UI-agnostic utilities only.
2. **All directories are lowercase-kebab-case**, except Next.js dynamic segments (e.g. `[userId]`).
3. **Files use PascalCase** for React components, `camelCase` for helpers.

### Recent Improvements

- **Eliminated ambiguous "shared" folder**: Reorganized into clear, conventional directories (`types/`, `constants/`, `test-utils/`) for better developer experience.
- **Added path aliases**: New aliases for `@types/*`, `@constants/*`, and `@test-utils` improve import ergonomics.
- **Centralized utilities**: Moved blood marker processing and metric calculations to `src/lib/` for better reusability.

---

## 2. Path Aliases (tsconfig.json)

```jsonc
"paths": {
  "@/*":             ["./src/*"],
  "@components/*":   ["./src/components/*"],
  "@ui/*":           ["./src/components/*"],
  "@features/*":     ["./src/features/*"],
  "@lib/*":          ["./src/lib/*"],
  "@types/*":        ["./src/types/*"],
  "@constants/*":    ["./src/constants/*"],
  "@test-utils":     ["./src/test-utils"],
  "@providers/*":    ["./src/providers/*"],
  "@server/*":       ["./src/server/*"],
  "@db/*":           ["./src/db/*"]
}
```
Use these instead of long relative paths.

---

## 3. Types

- `types/` (repo root): Ambient declarations only (e.g., NextAuth module augmentation, third‑party `.d.ts`). These are discovered via `typeRoots` in `tsconfig.json`.
- `src/types/`: Domain and API types used across the app (interfaces, unions, DTOs). No ambient declarations here.

---
### Plain‑English: why two "types" places?

- Root `types/` → think "tell TypeScript about libraries". Holds ambient `.d.ts` files that extend or describe third‑party modules. You don't import these; TypeScript finds them automatically.
- `src/types/` → think "our app's shapes". Regular `.ts` files you import everywhere for domain models and DTOs.
- `.next/types/` → generated by Next.js during build. Temporary helper types; never edit. We include it in `tsconfig` so Next.js' internals type-check correctly.
- There is no `src/app/types` in this project. If it appears, it's likely leftover and should be removed.

---

## 4. Component Guidelines

* Prefer **server components**; mark client components explicitly with `'use client'`.
* One component per file; export named components.
* Keep story/tests adjacent (`MyComp.test.tsx`, `MyComp.stories.tsx`).

### Feature ownership & barrels

- **Feature-owned UI** lives under `src/features/<feature>/components`. Avoid putting feature UI in `src/components`.
- Add a local barrel when helpful: `src/features/<feature>/components/index.ts`.
- Examples:

```ts
// Feature components (recommended)
import AddExperimentModal from '@features/experiments/components/AddExperimentModal';
import BloodTestUpload from '@features/blood-markers/components/BloodTestUpload';

// Shared primitives
import { ConfirmDialog } from '@components/ui';

// Types, constants, and utilities
import type { ChartData } from '@types/dashboard';
import { SLEEP_STAGE_TARGETS } from '@constants/sleep';
import { aggregateData } from '@lib/metric-calculations';
```

### App providers

- App-level providers live in `src/providers`.
- Example usage in `src/app/layout.tsx`:

```tsx
import { SessionProvider } from '@providers/SessionProvider';
import { ThemeProvider } from '@providers/ThemeProvider';

// ...
<SessionProvider>
  <ThemeProvider>{children}</ThemeProvider>
</SessionProvider>
```

### Compatibility re-exports

- During migration, some files in `src/components/*` may re-export from `src/features/*` to avoid breaking legacy paths. Prefer importing from `@features/*` going forward.

---

## 5. Server Modules (`src/server`)

Server-only modules encapsulate integrations and domain logic. Prefer importing from these instead of calling SDKs directly in routes.

Examples:

```ts
// S3 helpers
import { listDataFiles, fetchAllHealthData } from '@/server/aws/s3';

// Stripe helpers
import stripe, { hasUserPurchasedProduct } from '@/server/payments/stripe';

// Background jobs
import { createProcessingJob, getProcessingJob } from '@/server/jobs/processingJobs';

// Lambda
import { invokeLambda } from '@/server/aws/lambda';

// DB client
import clientPromise from '@/db/client';
```

`src/server/index.ts` provides barrels if you want to group imports.

### Processing flows

- Canonical imports for processing live under `src/server/processing`.

```ts
import { processHealthData } from '@server/processing/processHealthData';
```

### Barrels & canonical imports

- Prefer importing from canonical modules (`@server/aws/s3`, `@server/payments/stripe`, `@db/client`, `@features/<feature>/components`).
- Add `index.ts` barrels in folders with multiple exports to keep imports ergonomic.

---

## 6. Styling & UI

* **Tailwind CSS** with a mobile-first approach.
* Radix UI + Shadcn for accessible primitives.
* Use utility classes; avoid custom CSS unless necessary.

---

## 7. Testing & Coverage

### Testing Framework

* **Jest + React Testing Library** for unit and integration tests.
* Tests live next to code (e.g. `TrendIndicator.test.tsx`).
* Custom test utilities in `src/test-utils/` provide consistent setup.

```ts
// Use custom render with providers
import { render, screen } from '@test-utils';

// Instead of raw React Testing Library
// import { render, screen } from '@testing-library/react';
```

### Available Test Commands

```bash
# Basic testing
npm test                    # Run all tests once
npm run test:watch         # Run tests in watch mode
npm run test:changed       # Run tests for changed files only

# Coverage commands
npm run test:coverage      # Run tests with coverage report
npm run test:coverage:watch # Coverage in watch mode
npm run coverage:report    # Detailed coverage analysis
npm run coverage:open      # Open HTML coverage report
npm run coverage:check     # Verify coverage meets thresholds
npm run coverage:changed   # Check coverage for changed files only

# CI/CD
npm run test:ci           # Optimized for CI environments
```

### Pre-commit Testing

Pre-commit hooks automatically run:
1. **ESLint** with auto-fix on staged files
2. **Tests** for files related to your changes
3. **No coverage enforcement** during commits (encourages frequent commits)

Pre-push hooks run:
1. **Full test suite** to ensure nothing is broken
2. **Coverage check for changed files** with stricter requirements

### Coverage Standards

#### Global Thresholds (Baseline)
- **Global minimum**: 7% branches, 6% functions, 4% lines/statements
- **Business logic** (`src/lib/`): Higher standards (40-45%)

#### Changed Files Requirements (Pre-Push)
Stricter standards for new/modified code:
- **Components**: 60% statements, 50% branches, 60% functions
- **Hooks**: 70% statements, 60% branches, 80% functions
- **Utils/Lib**: 80-85% statements, 70-75% branches, 90% functions
- **API Routes**: 70% statements, 60% branches, 80% functions
- **Default**: 50% statements, 40% branches, 50% functions

This ensures **new code is well-tested** while allowing gradual improvement of legacy code.

### Coverage Improvement Strategy

1. **Phase 1**: Test utility functions (`src/lib/`)
   - `blood-marker-processing.ts` - Critical data transformation
   - `metric-calculations.ts` - Mathematical operations
   - `utils.ts` - Helper functions

2. **Phase 2**: Test key components
   - Dashboard components with complex logic
   - Form validation and data submission
   - Critical user flows

3. **Phase 3**: Integration tests
   - API endpoints (`src/app/api/`)
   - Full user workflows
   - Error handling paths

### Best Practices

```ts
// ✅ Good: Test behavior, not implementation
test('should display user name when loaded', async () => {
  render(<UserProfile userId="123" />);
  expect(await screen.findByText('John Doe')).toBeInTheDocument();
});

// ❌ Avoid: Testing internal state
test('should set loading to false', () => {
  const wrapper = shallow(<UserProfile />);
  expect(wrapper.state('loading')).toBe(false);
});
```

**Key Principles**:
- Test user-visible behavior, not implementation details
- Focus on critical paths first (authentication, data processing, payments)
- Write genuine tests that catch real bugs, not just to increase coverage
- Use descriptive test names that explain the expected behavior

---

## 8. Scripts & Infrastructure

* All operational scripts live in `infra/scripts`.
* Cloud resources (Lambda bundle, policies) under `infra/aws`.

Note: Historic shims under `src/server/services/*` and duplicate libs under `src/lib/*` were removed in favor of canonical modules in `src/server/*` and `src/db/*`.

---

## 9. Adding a New Feature

1. Create a folder in `src/features` (`kebab-case`).
2. Add hooks, utils, and components there (`components/`, `utils/`). Keep domain-specific utilities with the feature (e.g., `@features/health-data/utils`).
3. If you need API endpoints, add route handlers under `src/app/api/feature-name`.
4. Only use `src/lib` for cross-cutting, UI-agnostic helpers. Otherwise keep helpers inside the feature.

### Leaderboard Feature Example

The leaderboard feature demonstrates the complete feature-based architecture:

```
src/features/leaderboard/
├── components/           # UI components
│   ├── __tests__/       # Component tests
│   ├── LeaderboardPage.tsx
│   ├── LeaderboardHeader.tsx
│   ├── LeaderboardTabs.tsx
│   ├── LeaderboardTable.tsx
│   ├── LeaderboardEntry.tsx
│   ├── LoadingState.tsx
│   └── index.ts         # Barrel exports
├── hooks/               # Custom hooks
│   ├── __tests__/       # Hook tests
│   ├── useLeaderboardData.ts
│   ├── useLeaderboardFilters.ts
│   └── index.ts
├── utils/               # Feature utilities
│   ├── __tests__/       # Utility tests
│   ├── rank-helpers.ts
│   ├── leaderboard-calculations.ts
│   ├── constants.ts
│   └── index.ts
├── types/               # Feature types
│   └── index.ts
└── index.ts             # Main feature export
```

**Server-side business logic** lives in `src/server/leaderboard/`:

```
src/server/leaderboard/
├── calculations.ts      # Core leaderboard generation
├── profile-images.ts    # S3 image URL handling
├── types.ts            # Server-only types
└── index.ts            # Server exports
```

**API routes** are thin wrappers:

```ts
// ✅ Good: Thin API route (24 lines)
import { generateLeaderboard } from '@/server/leaderboard';

export async function GET() {
  const result = await generateLeaderboard('hrv', options);
  return NextResponse.json({ success: true, data: result.entries });
}

// ❌ Bad: Business logic in route (145+ lines)
export async function GET() {
  const client = await clientPromise;
  const users = await db.collection('users').find({})...
  // ... 140+ more lines of processing
}
```

### Key Benefits

- **Maintainability**: Business logic is separated and testable
- **Reusability**: Server modules can be used by multiple API routes
- **Performance**: Shared utilities reduce code duplication
- **Type Safety**: Proper TypeScript interfaces throughout
- **Testing**: Clean separation enables comprehensive testing

---

## 10. Authentication Architecture

The application uses **NextAuth.js** with a stable OAuth proxy system to handle authentication across all environments (production, preview deployments, and development).

### OAuth Proxy System

**Problem**: Vercel preview deployments create dynamic URLs that can't be pre-configured in OAuth provider settings. Google OAuth requires exact redirect URI matches.

**Solution**: A stable proxy subdomain (`auth.revly.health`) that handles OAuth callbacks and redirects to the appropriate environment.

#### Architecture Components

```
src/lib/auth.ts           # NextAuth configuration with proxy integration
src/lib/auth-proxy.ts     # Proxy utilities and state management  
src/lib/auth-secrets.ts   # Shared secret management
src/app/api/auth/proxy/   # OAuth proxy endpoint
```

#### Flow Diagram

```
1. User initiates OAuth from any environment (prod/preview/dev)
   ↓
2. OAuth provider redirects to: https://auth.revly.health/api/auth/proxy
   ↓
3. Proxy validates state and determines target environment
   ↓
4. Redirect to: {original-environment}/api/auth/callback/google
   ↓
5. NextAuth completes authentication flow
```

#### Security Features

- **State Validation**: HMAC signatures prevent tampering
- **Timestamp Expiry**: States expire after 10 minutes
- **Environment Detection**: Automatic URL resolution for all environments
- **Error Handling**: Comprehensive fallbacks for edge cases

#### Environment Configuration

**Production**:
- `OAUTH_PROXY_URL=https://auth.revly.health/api/auth/proxy`
- `USE_OAUTH_PROXY=true`

**Preview Deployments**: 
- `USE_OAUTH_PROXY=true` (proxy URL auto-detected)

**Development**:
- Direct OAuth (no proxy needed for localhost)

#### Supported Authentication Flows

- **Web Authentication**: Standard Google OAuth flow
- **iOS Authentication**: Custom callback handling for mobile app
- **Session Management**: JWT-based sessions with secure cookies

### Route Structure

```
src/app/api/auth/
├── [...nextauth]/route.ts    # NextAuth core endpoints
├── proxy/route.ts            # OAuth proxy for stable redirects
├── ios/route.ts             # iOS-specific auth endpoints
└── user-status/route.ts     # Authentication status checks
```

### Key Benefits

- **Seamless Deployments**: OAuth works on all preview URLs without manual configuration
- **Security**: State validation prevents OAuth attacks
- **Scalability**: One-time setup supports unlimited preview deployments  
- **Developer Experience**: No manual OAuth configuration for each deployment

---

_Feel free to extend this document as the project evolves._

